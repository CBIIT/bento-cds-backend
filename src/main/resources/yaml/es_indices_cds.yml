# Indices settings
Indices:
# Subjects index
  - index_name: subjects
    type: neo4j
    # type mapping for each property of the index
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Global Search properties
      site_gs:
        type: search_as_you_type
      study_gs:
        type: search_as_you_type
      subject_id_gs:
        type: search_as_you_type
      gender_gs:
        type: search_as_you_type
      # Overview properties
      files:
        type: keyword
      samples:
        type: keyword
      subject_ids:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(p:participant)
      WITH s, 
        {
          accesses: s.study_access,
          acl: s.acl,
          phs_accession: s.phs_accession,
          studies: s.study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p)
        } AS opensearch_data
      WITH s,
        apoc.map.merge(opensearch_data, {
          study_gs: opensearch_data.studies
        }) AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(p:participant)
      WITH p, 
        \"Not specified in data\" AS na, 
        apoc.map.merge(opensearch_data, {
          genders: p.gender,
          subject_ids: p.participant_id
        }) AS opensearch_data
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          gender_gs: opensearch_data.genders,
          subject_id_gs: opensearch_data.subject_ids
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          is_tumor: apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))),
          samples: apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na)))
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(:sample)<--(f:file)
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          experimental_strategies: apoc.coll.sort(apoc.coll.toSet(apoc.coll.flatten(COLLECT (apoc.text.split(f.experimental_strategy_and_data_subtypes,\"[;,]\\s{0,1}\")), true))),
          file_types: apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_type, na))),
          files: apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_id, na)))
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH p, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na))) AS primary_site,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_diagnosis, na))) AS primary_diagnosis
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: primary_diagnosis,
          site: primary_site,
          site_gs: primary_site
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(:sample)<--(:file)<--(g:genomic_info)
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          library_layouts: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))),
          library_selections: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))),
          library_sources: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))), 
          library_strategies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))),
          instrument_models: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))),
          platforms: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))),
          reference_genome_assemblies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na)))
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.subject_ids
      "
# Samples index
  - index_name: samples
    type: neo4j
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      sample_type:
        type: keyword
      sample_tumor_status:
        type: keyword
      sample_anatomic_site:
        type: keyword
      sample_age_at_collection:
        type: integer
      derived_from_specimen:
        type: keyword
      biosample_accession:
        type: keyword
      genders:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Global search properties
      sample_id_gs:
        type: search_as_you_type
      is_tumor_gs:
        type: search_as_you_type
      analyte_type_gs:
        type: search_as_you_type
      # Overview properties
      analyte_type:
        type: keyword
      sample_id:
        type: keyword
      sample_ids:
        type: keyword
      subject_ids:
        type: keyword
      participant:
        type: nested
        properties:
          participant_id:
            type: keyword
          race:
            type: keyword
          gender:
            type: keyword
          ethnicity:
            type: keyword
          dbGaP_subject_id:
            type: keyword
      specimen:
        type: nested
        properties:
          specimen_id:
            type: keyword
      files:
        type: nested
        properties:
          file_id:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: long
          file_size:
            type: long
          md5sum:
            type: keyword
          file_url_in_cds:
            type: keyword
          experimental_strategy_and_data_subtypes:
            type: keyword
      genomic_info:
        type: nested
        properties:
          library_id:
            type: keyword
          bases:
            type: float
          number_of_reads:
            type: float
          avg_read_length:
            type: float
          coverage:
            type: float
          reference_genome_assembly:
            type: keyword
          custom_assembly_fasta_file_for_alignment:
            type: keyword
          design_description:
            type: keyword
          library_strategy:
            type: keyword
          library_layout:
            type: keyword
          library_source:
            type: keyword
          library_selection:
            type: keyword
          platform:
            type: keyword
          instrument_model:
            type: keyword
          sequence_alignment_software:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(p:participant)
      WITH s, p, s.study_name AS study_name
      WITH s, 
        {
          accesses: s.study_access,
          acl: s.acl,
          phs_accession: s.phs_accession,
          studies: study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p)
        } AS opensearch_data
      MATCH (s)<--(:participant)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(:participant)<--(samp:sample)
      WITH samp, 
        \"Not specified in data\" AS na, 
        apoc.map.merge(opensearch_data, {
          is_tumor: samp.sample_tumor_status,
          analyte_type: samp.sample_type,
          sample_id: samp.sample_id,
          sample_ids: samp.sample_id
        }) AS opensearch_data
      WITH samp, na, 
      apoc.map.merge(opensearch_data, {
          is_tumor_gs: opensearch_data.is_tumor,
          analyte_type_gs: opensearch_data.analyte_type,
          sample_id_gs: opensearch_data.sample_id
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      OPTIONAL MATCH (samp)-->(spec:specimen)
      WITH samp, na,
        apoc.map.merge(opensearch_data, {
          genders: p.gender,
          subject_ids: p.participant_id,
          participant: CASE WHEN p IS NOT NULL THEN {
            participant_id: p.participant_id,
            race: p.race,
            gender: p.gender,
            ethnicity: p.ethnicity,
            dbGaP_subject_id: p.dbGaP_subject_id
            } ELSE NULL END,
          specimen: CASE WHEN spec IS NOT NULL THEN {
            specimen_id: spec.specimen_id
            } ELSE NULL END
        }) AS opensearch_data
      OPTIONAL MATCH (samp)<--(f:file)
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          experimental_strategies: apoc.coll.sort(apoc.coll.toSet(apoc.coll.flatten(COLLECT (apoc.text.split(f.experimental_strategy_and_data_subtypes,\"[;,]\\s{0,1}\")), true))),
          file_types: apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_type, na))),
          files: CASE WHEN f IS NOT NULL THEN COLLECT(DISTINCT {
            file_id: f.file_id,
            file_name: f.file_name,
            file_type: f.file_type,
            file_description: f.file_description,
            file_size: f.file_size,
            md5sum: f.md5sum,
            file_url_in_cds: f.file_url_in_cds,
            experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes
          }) ELSE NULL END
        }) AS opensearch_data
      OPTIONAL MATCH (samp)<--(:file)<--(g:genomic_info)
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          library_layouts: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))), 
          library_selections: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))), 
          library_sources: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))), 
          library_strategies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))),
          instrument_models: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))),
          platforms: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))),
          reference_genome_assemblies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na))),
          genomic_info: CASE WHEN g IS NOT NULL THEN COLLECT(DISTINCT {
            library_id: g.library_id,
            sample_type: g.sample_type,
            bases: g.bases,
            number_of_reads: g.number_of_reads,
            avg_read_length: g.avg_read_length,
            coverage: g.coverage,
            reference_genome_assembly: g.reference_genome_assembly,
            custom_assembly_fasta_file_for_alignment: g.custom_assembly_fasta_file_for_alignment,
            design_description: g.design_description,
            library_strategy: g.library_strategy,
            library_layout: g.library_layout,
            library_source: g.library_source,
            library_selection: g.library_selection,
            platform: g.platform,
            instrument_model: g.instrument_model,
            sequence_alignment_software: g.sequence_alignment_software
          }) ELSE NULL END
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(:participant)<--(diag:diagnosis)
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_diagnosis, na))),
          site: apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na)))
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.sample_id
    "
# Files index (split by experimental strategies)
  - index_name: file_experimental_strategies
    type: neo4j
    mapping:
      file_id:
        type: keyword
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
    cypher_query: "
      MATCH (s:study)<--(p:participant)
      WITH s, 
        {
          accesses: s.study_access,
          acl: s.acl,
          phs_accession: s.phs_accession,
          studies: s.study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p)
        } AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s, \"Not specified in data\" AS na,
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(f:file)
      UNWIND coalesce(apoc.text.split(f.experimental_strategy_and_data_subtypes,\"[;,]\\s{0,1}\"), na) AS experimental_strategies
      WITH f, na, opensearch_data, experimental_strategies, CASE WHEN f.file_type = na THEN na ELSE toUpper(f.file_type) END AS file_type 
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategies,
          file_types: file_type ,
          files: f.file_id,
          file_id: f.file_id,
          file_name: f.file_name,
          file_type: file_type,
          file_size: f.file_size,
          md5sum: f.md5sum
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(:sample)-->(p:participant)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.gender, na))) AS gender,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.participant_id, na))) AS participant_id
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          genders: gender,
          subject_ids: participant_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(samp:sample)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))) AS sample_tumor_status,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_type, na))) AS sample_type,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na))) AS sample_id
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          is_tumor: sample_tumor_status,
          analyte_type: sample_type,
          sample_ids: sample_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          library_layouts: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))), 
          library_selections: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))), 
          library_sources: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))), 
          library_strategies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))),
          instrument_models: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))),
          platforms: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))),
          reference_genome_assemblies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na)))
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(:sample)-->(:participant)<--(diag:diagnosis)
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_diagnosis, na))),
          site: apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na)))
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.files
    "
# Files index
  - index_name: files
    type: neo4j
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Overview properties
      analyte_type:
        type: keyword
      analyte_type_sort:
        type: keyword
      file_id:
        type: keyword
      file_ids:
        type: keyword
      file_name:
        type: keyword
      file_names:
        type: keyword
      file_description:
        type: keyword
      file_url_in_cds:
        type: keyword
      experimental_strategy_and_data_subtypes:
        type: keyword
      file_type:
        type: keyword
      file_size:
        type: long
      md5sum:
        type: keyword
      sample_id:
        type: keyword
      sample_ids:
        type: keyword
      subject_ids:
        type: keyword
      # Global search properties
      file_id_gs:
        type: search_as_you_type
      file_name_gs:
        type: search_as_you_type
      file_type_gs:
        type: search_as_you_type
      subject_id_gs:
        type: search_as_you_type
      sample_id_gs:
        type: search_as_you_type
      accesses_gs:
        type: search_as_you_type
      acl_gs:
        type: search_as_you_type
      experimental_strategies_gs:
        type: search_as_you_type
      instrument_models_gs:
        type: search_as_you_type
      library_layouts_gs:
        type: search_as_you_type
      library_selections_gs:
        type: search_as_you_type
      library_sources_gs:
        type: search_as_you_type
      library_strategies_gs:
        type: search_as_you_type
      platforms_gs:
        type: search_as_you_type
      reference_genome_assemblies_gs:
        type: search_as_you_type
      samples:
        type: nested
        properties:
          sample_id:
            type: keyword
          sample_type:
            type: keyword
          sample_tumor_status:
            type: keyword
          sample_anatomic_site:
            type: keyword
          sample_age_at_collection:
            type: integer
          derived_from_specimen:
            type: keyword
          biosample_accession:
            type: keyword
      genomic_info:
        type: nested
        properties:
          library_id:
            type: keyword
          bases:
            type: float
          number_of_reads:
            type: float
          avg_read_length:
            type: float
          coverage:
            type: float
          reference_genome_assembly:
            type: keyword
          custom_assembly_fasta_file_for_alignment:
            type: keyword
          design_description:
            type: keyword
          library_strategy:
            type: keyword
          library_layout:
            type: keyword
          library_source:
            type: keyword
          library_selection:
            type: keyword
          platform:
            type: keyword
          instrument_model:
            type: keyword
          sequence_alignment_software:
            type: keyword
      study:
        type: nested
        properties:
          study_name:
            type: keyword
          study_acronym:
            type: keyword
          study_description:
            type: keyword
          short_description:
            type: keyword
          study_external_url:
            type: keyword
          primary_investigator_name:
            type: keyword
          primary_investigator_email:
            type: keyword
          co_investigator_name:
            type: keyword
          co_investigator_email:
            type: keyword
          phs_accession:
            type: keyword
          bioproject_accession:
            type: keyword
          index_date:
            type: keyword
          cds_requestor:
            type: keyword
          funding_agency:
            type: keyword
          funding_source_program_name:
            type: keyword
          grant_id:
            type: keyword
          clinical_trial_system:
            type: keyword
          clinical_trial_identifier:
            type: keyword
          clinical_trial_arm:
            type: keyword
          organism_species:
            type: keyword
          adult_or_childhood_study:
            type: keyword
          data_types:
            type: keyword
          file_types:
            type: keyword
          data_access_level:
            type: keyword
          cds_primary_bucket:
            type: keyword
          cds_secondary_bucket:
            type: keyword
          cds_tertiary_bucket:
            type: keyword
          number_of_participants:
            type: keyword
          number_of_samples:
            type: float
          study_data_types:
            type: keyword
          file_types_and_format:
            type: keyword
          size_of_data_being_uploaded:
            type: float
          size_of_data_being_uploaded_unit:
            type: keyword
          size_of_data_being_uploaded_original:
            type: float
          size_of_data_being_uploaded_original_unit:
            type: keyword
          acl:
            type: keyword
          study_access:
            type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(p:participant)
      WITH s, 
        {
          accesses: s.study_access,
          acl: s.acl,
          phs_accession: s.phs_accession,
          studies: s.study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p),
          accesses_gs: s.study_access,
          acl_gs: s.acl
        } AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(f:file)
      WITH f, \"Not specified in data\" AS na, opensearch_data, CASE WHEN s IS NOT NULL THEN {
        study_name: s.study_name,
        study_acronym: s.study_acronym,
        study_description: s.study_description,
        short_description: s.short_description,
        study_external_url: s.study_external_url,
        primary_investigator_name: s.primary_investigator_name,
        primary_investigator_email: s.primary_investigator_email,
        co_investigator_name: s.co_investigator_name,
        co_investigator_email: s.co_investigator_email,
        phs_accession: s.phs_accession,
        bioproject_accession: s.bioproject_accession,
        index_date: s.index_date,
        cds_requestor: s.cds_requestor,
        funding_agency: s.funding_agency,
        funding_source_program_name: s.funding_source_program_name,
        grant_id: s.grant_id,
        clinical_trial_system: s.clinical_trial_system,
        clinical_trial_identifier: s.clinical_trial_identifier,
        clinical_trial_arm: s.clinical_trial_arm,
        organism_species: s.organism_species,
        adult_or_childhood_study: s.adult_or_childhood_study,
        data_types: s.data_types,
        file_types: s.file_types,
        data_access_level: s.data_access_level,
        cds_primary_bucket: s.cds_primary_bucket,
        cds_secondary_bucket: s.cds_secondary_bucket,
        cds_tertiary_bucket: s.cds_tertiary_bucket,
        number_of_participants: s.number_of_participants,
        number_of_samples: s.number_of_samples,
        study_data_types: s.study_data_types,
        file_types_and_format: s.file_types_and_format,
        size_of_data_being_uploaded: s.size_of_data_being_uploaded,
        size_of_data_being_uploaded_unit: s.size_of_data_being_uploaded_unit,
        size_of_data_being_uploaded_original: s.size_of_data_being_uploaded_original,
        size_of_data_being_uploaded_original_unit: s.size_of_data_being_uploaded_original_unit,
        acl: s.acl,
        study_access: s.study_access
      } ELSE NULL END AS study
      WITH f, na, opensearch_data, study,
        CASE WHEN f.file_type = na THEN na ELSE toUpper(f.file_type) END AS file_type, 
        apoc.coll.sort(apoc.coll.toSet(apoc.coll.flatten(COLLECT(coalesce(apoc.text.split(f.experimental_strategy_and_data_subtypes,\"[;,]\\s{0,1}\"), na)),true))) AS experimental_strategy_and_data_subtypes
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategy_and_data_subtypes,
          file_types: file_type ,
          files: f.file_id,
          file_id: f.file_id,
          file_ids: f.file_id,
          file_name: f.file_name,
          file_names: f.file_name,
          file_type: file_type,
          file_description: f.file_description,
          file_url_in_cds: f.file_url_in_cds,
          experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes,
          file_size: f.file_size,
          md5sum: f.md5sum,
          experimental_strategies_gs: experimental_strategy_and_data_subtypes,
          file_type_gs: f.file_type ,
          file_id_gs: f.file_id,
          file_name_gs: f.file_name,
          study: study
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(:sample)-->(p:participant)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.gender, na))) AS gender,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.participant_id, na))) AS participant_id
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          genders: gender,
          subject_ids: participant_id,
          subject_id_gs: participant_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(samp:sample)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))) AS sample_tumor_status,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_type, na))) AS sample_type,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na))) AS sample_id,
        CASE WHEN samp IS NOT NULL THEN COLLECT(DISTINCT {
          sample_id: samp.sample_id,
          sample_type: samp.sample_type,
          sample_tumor_status: samp.sample_tumor_status,
          sample_anatomic_site: samp.sample_anatomic_site,
          sample_age_at_collection: samp.sample_age_at_collection,
          derived_from_specimen: samp.derived_from_specimen,
          biosample_accession: samp.biosample_accession          
        }) ELSE NULL END AS samples
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          is_tumor: sample_tumor_status,
          analyte_type: sample_type,
          analyte_type_sort: apoc.text.join(sample_type, ''),
          sample_id: sample_id,
          sample_ids: sample_id,
          sample_id_gs: sample_id,
          samples: samples
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))) AS library_layout,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))) AS library_selection,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))) AS library_source,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))) AS library_strategy,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))) AS instrument_model,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))) AS platform,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na))) AS reference_genome_assembly,
        CASE WHEN g IS NOT NULL THEN COLLECT(DISTINCT {
          library_id: g.library_id,
          bases: g.bases,
          number_of_reads: g.number_of_reads,
          avg_read_length: g.avg_read_length,
          coverage: g.coverage,
          reference_genome_assembly: g.reference_genome_assembly,
          custom_assembly_fasta_file_for_alignment: g.custom_assembly_fasta_file_for_alignment,
          design_description: g.design_description,
          library_strategy: g.library_strategy,
          library_layout: g.library_layout,
          library_source: g.library_source,
          library_selection: g.library_selection,
          platform: g.platform,
          instrument_model: g.instrument_model,
          sequence_alignment_software: g.sequence_alignment_software
        }) ELSE NULL END AS genomic_info
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          library_layouts: library_layout, 
          library_selections: library_selection, 
          library_sources: library_source, 
          library_strategies: library_strategy,
          instrument_models: instrument_model,
          platforms: platform,
          reference_genome_assemblies: reference_genome_assembly,
          library_layouts_gs: library_layout, 
          library_selections_gs: library_selection, 
          library_sources_gs: library_source, 
          library_strategies_gs: library_strategy,
          instrument_models_gs: instrument_model,
          platforms_gs: platform,
          reference_genome_assemblies_gs: reference_genome_assembly,
          genomic_info: genomic_info
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(:sample)-->(:participant)<--(diag:diagnosis)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_diagnosis, na))) AS primary_diagnosis,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na))) AS primary_site
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: primary_diagnosis,
          site: primary_site,
          sites_gs: primary_site
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.files
    "

  - index_name: treatment
    type: neo4j
    # type mapping for each property of the index
    mapping:
      treatment_id:
        type: keyword
      treatment_type:
        type: keyword
      treatment_outcome:
        type: keyword
      days_to_treatment:
        type: keyword
      therapeutic_agents:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (t:treatment)
      RETURN
        t.treatment_id AS treatment_id,
        t.treatment_type AS treatment_type,
        t.treatment_outcome AS treatment_outcome,
        t.days_to_treatment AS days_to_treatment,
        t.therapeutic_agents AS therapeutic_agents
    "

  - index_name: genomic_info
    type: neo4j
    # type mapping for each property of the index
    mapping:
      library_id:
        type: keyword
      bases:
        type: float
      number_of_reads:
        type: float
      avg_read_length:
        type: float
      coverage:
        type: float
      reference_genome_assembly:
        type: keyword
      custom_assembly_fasta_file_for_alignment:
        type: keyword
      design_description:
        type: keyword
      library_strategy:
        type: keyword
      library_layout:
        type: keyword
      library_source:
        type: keyword
      library_selection:
        type: keyword
      platform:
        type: keyword
      instrument_model:
        type: keyword
      sequence_alignment_software:
        type: keyword
      files:
        type: nested
        properties:
          file_id:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: keyword
          file_size:
            type: keyword
          md5sum:
            type: keyword
          file_url_in_cds:
            type: keyword
          experimental_strategy_and_data_subtypes:
            type: keyword
      samples:
        type: nested
        properties:
          sample_id:
            type: keyword
          sample_type:
            type: keyword
          sample_tumor_status:
            type: keyword
          sample_anatomic_site:
            type: keyword
          sample_age_at_collection:
            type: integer
          derived_from_specimen:
            type: keyword
          biosample_accession:
            type: keyword
      file:
        type: nested
        properties:
          file_id:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: keyword
          file_size:
            type: keyword
          md5sum:
            type: keyword
          file_url_in_cds:
            type: keyword
          experimental_strategy_and_data_subtypes:
            type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (n:genomic_info)
      OPTIONAL MATCH (n)-[:of_file]-(f:file)
      OPTIONAL MATCH (n)-[:from_genomic_info]-(gf:file)
      OPTIONAL MATCH (n)<--(samp:sample)
      RETURN
        n.library_id AS library_id,
        n.bases AS bases,
        n.number_of_reads AS number_of_reads,
        n.avg_read_length AS avg_read_length,
        n.coverage AS coverage,
        n.reference_genome_assembly AS reference_genome_assembly,
        n.custom_assembly_fasta_file_for_alignment AS custom_assembly_fasta_file_for_alignment,
        n.design_description AS design_description,
        n.library_strategy AS library_strategy,
        n.library_layout AS library_layout,
        n.library_source AS library_source,
        n.library_selection AS library_selection,
        n.platform AS platform,
        n.instrument_model AS instrument_model,
        n.sequence_alignment_software AS sequence_alignment_software,
        CASE WHEN gf IS NOT NULL THEN COLLECT(DISTINCT {
            file_id: gf.file_id,
            file_name: gf.file_name,
            file_type: gf.file_type,
            file_description: gf.file_description,
            file_size: gf.file_size,
            md5sum: gf.md5sum,
            file_url_in_cds: gf.file_url_in_cds,
            experimental_strategy_and_data_subtypes: gf.experimental_strategy_and_data_subtypes
        }) ELSE NULL END as files,
        CASE WHEN samp IS NOT NULL THEN COLLECT(DISTINCT {
          sample_id: samp.sample_id,
          sample_type: samp.sample_type,
          sample_tumor_status: samp.sample_tumor_status,
          sample_anatomic_site: samp.sample_anatomic_site,
          sample_age_at_collection: samp.sample_age_at_collection,
          derived_from_specimen: samp.derived_from_specimen,
          biosample_accession: samp.biosample_accession
        }) ELSE NULL END AS samples,
        CASE WHEN f IS NOT NULL THEN COLLECT(DISTINCT {
            file_id: f.file_id,
            file_name: f.file_name,
            file_type: f.file_type,
            file_description: f.file_description,
            file_size: f.file_size,
            md5sum: f.md5sum,
            file_url_in_cds: f.file_url_in_cds,
            experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes
        }) ELSE NULL END as file
      "

# Programs index
  - index_name: programs
    type: neo4j
    # type mapping for each property of the index
    mapping:
      program_name:
        type: search_as_you_type
      program_acronym:
        type: search_as_you_type
      program_short_description:
        type: search_as_you_type
      program_full_description:
        type: search_as_you_type
      program_external_url:
        type: search_as_you_type
      program_sort_order:
        type: search_as_you_type
      program_sort_order_kw:
        type: keyword
      studies:
        type: nested
        properties:
          study_name:
            type: keyword
          study_acronym:
            type: keyword
          study_description:
            type: keyword
          short_description:
            type: keyword
          study_external_url:
            type: keyword
          primary_investigator_name:
            type: keyword
          primary_investigator_email:
            type: keyword
          co_investigator_name:
            type: keyword
          co_investigator_email:
            type: keyword
          phs_accession:
            type: keyword
          bioproject_accession:
            type: keyword
          index_date:
            type: keyword
          cds_requestor:
            type: keyword
          funding_agency:
            type: keyword
          funding_source_program_name:
            type: keyword
          grant_id:
            type: keyword
          clinical_trial_system:
            type: keyword
          clinical_trial_identifier:
            type: keyword
          clinical_trial_arm:
            type: keyword
          organism_species:
            type: keyword
          adult_or_childhood_study:
            type: keyword
          data_types:
            type: keyword
          file_types:
            type: keyword
          data_access_level:
            type: keyword
          cds_primary_bucket:
            type: keyword
          cds_secondary_bucket:
            type: keyword
          cds_tertiary_bucket:
            type: keyword
          number_of_participants:
            type: keyword
          number_of_samples:
            type: float
          file_types_and_format:
            type: keyword
          size_of_data_being_uploaded:
            type: float
          size_of_data_being_uploaded_unit:
            type: keyword
          size_of_data_being_uploaded_original:
            type: float
          size_of_data_being_uploaded_original_unit:
            type: keyword
          acl:
            type: keyword
          study_access:
            type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:program)
      WITH p, \"program\" as type
      RETURN
        p.program_name AS program_name,
        p.program_short_description AS program_short_description,
        p.program_full_description AS program_full_description,
        p.program_external_url AS program_external_url,
        p.program_sort_order AS program_sort_order,
        p.program_sort_order AS program_sort_order_kw,
        type
    "
# Studies index
  - index_name: studies
    type: neo4j
    # type mapping for each property of the index
    mapping:
      study_code:
        type: keyword
      study_data_types:
        type: keyword
      study_code_gs:
        type: search_as_you_type
      phs_accession_gs:
        type: search_as_you_type
      study_name_gs:
        type: search_as_you_type
      study_data_types_gs:
        type: search_as_you_type
      study_name:
        type: keyword
      study_acronym:
        type: keyword
      study_description:
        type: keyword
      short_description:
        type: keyword
      study_external_url:
        type: keyword
      primary_investigator_name:
        type: keyword
      primary_investigator_email:
        type: keyword
      co_investigator_name:
        type: keyword
      co_investigator_email:
        type: keyword
      phs_accession:
        type: keyword
      bioproject_accession:
        type: keyword
      index_date:
        type: keyword
      cds_requestor:
        type: keyword
      funding_agency:
        type: keyword
      funding_source_program_name:
        type: keyword
      grant_id:
        type: keyword
      clinical_trial_system:
        type: keyword
      clinical_trial_identifier:
        type: keyword
      clinical_trial_arm:
        type: keyword
      organism_species:
        type: keyword
      adult_or_childhood_study:
        type: keyword
      data_types:
        type: keyword
      file_types:
        type: keyword
      data_access_level:
        type: keyword
      cds_primary_bucket:
        type: keyword
      cds_secondary_bucket:
        type: keyword
      cds_tertiary_bucket:
        type: keyword
      number_of_participants:
        type: keyword
      number_of_samples:
        type: float
      file_types_and_format:
        type: keyword
      size_of_data_being_uploaded:
        type: float
      size_of_data_being_uploaded_unit:
        type: keyword
      size_of_data_being_uploaded_original:
        type: float
      size_of_data_being_uploaded_original_unit:
        type: keyword
      acl:
        type: keyword
      study_access:
        type: keyword
      program:
        type: nested
        properties:
          program_name:
            type: search_as_you_type
          program_acronym:
            type: search_as_you_type
          program_short_description:
            type: search_as_you_type
          program_full_description:
            type: search_as_you_type
          program_external_url:
            type: search_as_you_type
          program_sort_order:
            type: search_as_you_type
          program_sort_order_kw:
            type: keyword
      participants:
        type: nested
        properties:
          participant_id:
            type: keyword
          race:
            type: keyword
          gender:
            type: keyword
          ethnicity:
            type: keyword
          dbGaP_subject_id:
            type: keyword
      files:
        type: nested
        properties:
          file_id:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: keyword
          file_size:
            type: keyword
          md5sum:
            type: keyword
          file_url_in_cds:
            type: keyword
          experimental_strategy_and_data_subtypes:
            type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)
      OPTIONAL MATCH (s)<--(f:file)
      WITH s, {
        study_code: s.study_name,
        study_code_gs: s.study_name,
        phs_accession_gs: s.phs_accession,
        phs_accession: s.phs_accession,
        study_name: s.study_name,
        study_name_gs: s.study_name,
        study_data_types: s.study_data_types,
        study_data_types_gs: s.study_data_types,
        short_description: s.short_description,
        study_acronym: s.study_acronym,
        study_description: s.study_description,
        study_external_url: s.study_external_url,
        primary_investigator_name: s.primary_investigator_name,
        primary_investigator_email: s.primary_investigator_email,
        co_investigator_name: s.co_investigator_name,
        co_investigator_email: s.co_investigator_email,
        bioproject_accession: s.bioproject_accession,
        index_date: s.index_date,
        cds_requestor: s.cds_requestor,
        funding_agency: s.funding_agency,
        funding_source_program_name: s.funding_source_program_name,
        grant_id: s.grant_id,
        clinical_trial_system: s.clinical_trial_system,
        clinical_trial_identifier: s.clinical_trial_identifier,
        clinical_trial_arm: s.clinical_trial_arm,
        organism_species: s.organism_species,
        adult_or_childhood_study: s.adult_or_childhood_study,
        data_types: s.data_types,
        file_types: s.file_types,
        data_access_level: s.data_access_level,
        cds_primary_bucket: s.cds_primary_bucket,
        cds_secondary_bucket: s.cds_secondary_bucket,
        cds_tertiary_bucket: s.cds_tertiary_bucket,
        number_of_participants: s.number_of_participants,
        number_of_samples: s.number_of_samples,
        file_types_and_format: s.file_types_and_format,
        size_of_data_being_uploaded: s.size_of_data_being_uploaded,
        size_of_data_being_uploaded_unit: s.size_of_data_being_uploaded_unit,
        size_of_data_being_uploaded_original: s.size_of_data_being_uploaded_original,
        size_of_data_being_uploaded_original_unit: s.size_of_data_being_uploaded_original_unit,
        acl: s.acl,
        study_access: s.study_access,
        files: CASE WHEN f IS NOT NULL THEN COLLECT(DISTINCT {
            file_id: f.file_id,
            file_name: f.file_name,
            file_type: f.file_type,
            file_description: f.file_description,
            file_size: f.file_size,
            md5sum: f.md5sum,
            file_url_in_cds: f.file_url_in_cds,
            experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes
          }) ELSE NULL END
      } AS opensearch_data
      OPTIONAL MATCH (s)<--(p:participant)
      OPTIONAL MATCH (s)-->(pro:program)
      WITH s,
        apoc.map.merge(opensearch_data, {
          number_of_participants: COUNT(DISTINCT p),
          program: CASE WHEN pro IS NOT NULL THEN {
            program_name: pro.program_name,
            program_acronym: pro.program_acronym,
            program_short_description: pro.program_short_description,
            program_full_description: pro.program_full_description,
            program_external_url: pro.program_external_url,
            program_sort_order: pro.program_sort_order
          } ELSE NULL END,
          participants: CASE WHEN p IS NOT NULL THEN COLLECT(DISTINCT {
            participant_id: p.participant_id,
            race: p.race,
            gender: p.gender,
            ethnicity: p.ethnicity,
            dbGaP_subject_id: p.dbGaP_subject_id
          }) ELSE NULL END
        }) AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s,
        apoc.map.merge(opensearch_data, {
          number_of_samples: COUNT(DISTINCT samp)
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.study_code
    "
  - index_name: specimen
    type: neo4j
    # type mapping for each property of the index
    mapping:
      specimen_id:
        type: keyword
      participant:
        type: nested
        properties:
          participant_id:
            type: keyword
          race:
            type: keyword
          gender:
            type: keyword
          ethnicity:
            type: keyword
          dbGaP_subject_id:
            type: keyword
      samples:
        type: nested
        properties:
          sample_id:
            type: keyword
          sample_type:
            type: keyword
          sample_tumor_status:
            type: keyword
          sample_anatomic_site:
            type: keyword
          sample_age_at_collection:
            type: integer
          derived_from_specimen:
            type: keyword
          biosample_accession:
            type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:specimen)
      OPTIONAL MATCH (s)<--(samp:sample)
      OPTIONAL MATCH (s)-->(p:participant)
      RETURN
        s.specimen_id AS specimen_id,
        CASE WHEN p IS NOT NULL THEN {
          participant_id: p.participant_id,
          race: p.race,
          gender: p.gender,
          ethnicity: p.ethnicity,
          dbGaP_subject_id: p.dbGaP_subject_id
        } ELSE NULL END AS participant,
        CASE WHEN samp IS NOT NULL THEN COLLECT(DISTINCT {
          sample_id: samp.sample_id,
          sample_type: samp.sample_type,
          sample_tumor_status: samp.sample_tumor_status,
          sample_anatomic_site: samp.sample_anatomic_site,
          sample_age_at_collection: samp.sample_age_at_collection,
          derived_from_specimen: samp.derived_from_specimen,
          biosample_accession: samp.biosample_accession
        }) ELSE NULL END
    "
# diagnosis index
  - index_name: diagnosis
    type: neo4j
    # type mapping for each property of the index
    mapping:
      diagnosis_id:
        type: keyword
      disease_type:
        type: keyword
      vital_status:
        type: keyword
      primary_diagnosis:
        type: keyword
      primary_site:
        type: keyword
      site:
        type: keyword
      age_at_diagnosis:
        type: keyword
      tumor_grade:
        type: keyword
      tumor_stage_clinical_m:
        type: keyword
      tumor_stage_clinical_n:
        type: keyword
      tumor_stage_clinical_t:
        type: keyword
      morphology:
        type: keyword
      incidence_type:
        type: keyword
      progression_or_recurrence:
        type: keyword
      days_to_recurrence:
        type: keyword
      days_to_last_followup:
        type: keyword
      last_known_disease_status:
        type: keyword
      days_to_last_known_status:
        type: keyword
      participant:
        type: nested
        properties:
          participant_id:
            type: keyword
          race:
            type: keyword
          gender:
            type: keyword
          ethnicity:
            type: keyword
          dbGaP_subject_id:
            type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (n:diagnosis)
      OPTIONAL MATCH (n)-->(p:participant)
      RETURN
        n.diagnosis_id AS diagnosis_id,
        n.disease_type AS disease_type,
        n.vital_status AS vital_status,
        n.primary_diagnosis AS primary_diagnosis,
        n.primary_site AS primary_site,
        n.primary_site AS site,
        n.age_at_diagnosis AS age_at_diagnosis,
        n.tumor_grade AS tumor_grade,
        n.tumor_stage_clinical_m AS tumor_stage_clinical_m,
        n.tumor_stage_clinical_n AS tumor_stage_clinical_n,
        n.tumor_stage_clinical_t AS tumor_stage_clinical_t,
        n.morphology AS morphology,
        n.incidence_type AS incidence_type,
        n.progression_or_recurrence AS progression_or_recurrence,
        n.days_to_recurrence AS days_to_recurrence,
        n.days_to_last_followup AS days_to_last_followup,
        n.last_known_disease_status AS last_known_disease_status,
        n.days_to_last_known_status AS days_to_last_known_status,
        CASE WHEN p IS NOT NULL THEN {
          participant_id: p.participant_id,
          race: p.race,
          gender: p.gender,
          ethnicity: p.ethnicity,
          dbGaP_subject_id: p.dbGaP_subject_id
        } ELSE NULL END AS participant
      "

  - index_name: participant
    type: neo4j
    # type mapping for each property of the index
    mapping:
      participant_id:
        type: keyword
      race:
        type: keyword
      gender:
        type: keyword
      ethnicity:
        type: keyword
      dbGaP_subject_id:
        type: keyword
      study:
        type: nested
        properties:
          study_name:
            type: keyword
          study_acronym:
            type: keyword
          study_description:
            type: keyword
          short_description:
            type: keyword
          study_external_url:
            type: keyword
          primary_investigator_name:
            type: keyword
          primary_investigator_email:
            type: keyword
          co_investigator_name:
            type: keyword
          co_investigator_email:
            type: keyword
          phs_accession:
            type: keyword
          bioproject_accession:
            type: keyword
          index_date:
            type: keyword
          cds_requestor:
            type: keyword
          funding_agency:
            type: keyword
          funding_source_program_name:
            type: keyword
          grant_id:
            type: keyword
          clinical_trial_system:
            type: keyword
          clinical_trial_identifier:
            type: keyword
          clinical_trial_arm:
            type: keyword
          organism_species:
            type: keyword
          adult_or_childhood_study:
            type: keyword
          data_types:
            type: keyword
          file_types:
            type: keyword
          data_access_level:
            type: keyword
          cds_primary_bucket:
            type: keyword
          cds_secondary_bucket:
            type: keyword
          cds_tertiary_bucket:
            type: keyword
          number_of_participants:
            type: keyword
          number_of_samples:
            type: float
          file_types_and_format:
            type: keyword
          size_of_data_being_uploaded:
            type: float
          size_of_data_being_uploaded_unit:
            type: keyword
          size_of_data_being_uploaded_original:
            type: float
          size_of_data_being_uploaded_original_unit:
            type: keyword
          acl:
            type: keyword
          study_access:
            type: keyword
      diagnoses:
        type: nested
        properties:
          diagnosis_id:
            type: keyword
          disease_type:
            type: keyword
          vital_status:
            type: keyword
          primary_diagnosis:
            type: keyword
          primary_site:
            type: keyword
          site:
            type: keyword
          age_at_diagnosis:
            type: keyword
          tumor_grade:
            type: keyword
          tumor_stage_clinical_m:
            type: keyword
          tumor_stage_clinical_n:
            type: keyword
          tumor_stage_clinical_t:
            type: keyword
          morphology:
            type: keyword
          incidence_type:
            type: keyword
          progression_or_recurrence:
            type: keyword
          days_to_recurrence:
            type: keyword
          days_to_last_followup:
            type: keyword
          last_known_disease_status:
            type: keyword
          days_to_last_known_status:
            type: keyword
      specimens:
        type: nested
        properties:
          specimen_id:
            type: keyword
      samples:
        type: nested
        properties:
          sample_id:
            type: keyword
          sample_type:
            type: keyword
          sample_tumor_status:
            type: keyword
          sample_anatomic_site:
            type: keyword
          sample_age_at_collection:
            type: integer
          derived_from_specimen:
            type: keyword
          biosample_accession:
            type: keyword
    #    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:participant)
      OPTIONAL MATCH (p)-->(s:study)
      OPTIONAL MATCH (p)<--(d:diagnosis)
      OPTIONAL MATCH (p)<--(spec:specimen)
      OPTIONAL MATCH (p)<--(samp:sample)
      RETURN
        p.participant_id as participant_id,
        p.race as race,
        p.gender as gender,
        p.ethnicity as ethnicity,
        p.dbGaP_subject_id as dbGaP_subject_id,
        CASE WHEN s IS NOT NULL THEN {
          study_name: s.study_name,
          study_acronym: s.study_acronym,
          study_description: s.study_description,
          short_description: s.short_description,
          study_external_url: s.study_external_url,
          primary_investigator_name: s.primary_investigator_name,
          primary_investigator_email: s.primary_investigator_email,
          co_investigator_name: s.co_investigator_name,
          co_investigator_email: s.co_investigator_email,
          phs_accession: s.phs_accession,
          bioproject_accession: s.bioproject_accession,
          index_date: s.index_date,
          cds_requestor: s.cds_requestor,
          funding_agency: s.funding_agency,
          funding_source_program_name: s.funding_source_program_name,
          grant_id: s.grant_id,
          clinical_trial_system: s.clinical_trial_system,
          clinical_trial_identifier: s.clinical_trial_identifier,
          clinical_trial_arm: s.clinical_trial_arm,
          organism_species: s.organism_species,
          adult_or_childhood_study: s.adult_or_childhood_study,
          data_types: s.data_types,
          file_types: s.file_types,
          data_access_level: s.data_access_level,
          cds_primary_bucket: s.cds_primary_bucket,
          cds_secondary_bucket: s.cds_secondary_bucket,
          cds_tertiary_bucket: s.cds_tertiary_bucket,
          number_of_participants: s.number_of_participants,
          number_of_samples: s.number_of_samples,
          study_data_types: s.study_data_types,
          file_types_and_format: s.file_types_and_format,
          size_of_data_being_uploaded: s.size_of_data_being_uploaded,
          size_of_data_being_uploaded_unit: s.size_of_data_being_uploaded_unit,
          size_of_data_being_uploaded_original: s.size_of_data_being_uploaded_original,
          size_of_data_being_uploaded_original_unit: s.size_of_data_being_uploaded_original_unit,
          acl: s.acl,
          study_access: s.study_access
        } ELSE NULL END AS study,
        CASE WHEN d IS NOT NULL THEN COLLECT(DISTINCT {
          diagnosis_id: d.diagnosis_id,
          disease_type: d.disease_type,
          vital_status: d.vital_status,
          primary_diagnosis: d.primary_diagnosis,
          primary_site: d.primary_site,
          site: d.site,
          age_at_diagnosis: d.age_at_diagnosis,
          tumor_grade: d.tumor_grade,
          tumor_stage_clinical_m: d.tumor_stage_clinical_m,
          tumor_stage_clinical_n: d.tumor_stage_clinical_n,
          tumor_stage_clinical_t: d.tumor_stage_clinical_t,
          morphology: d.morphology,
          incidence_type: d.incidence_type,
          progression_or_recurrence: d.progression_or_recurrence,
          days_to_recurrence: d.days_to_recurrence,
          days_to_last_followup: d.days_to_last_followup,
          last_known_disease_status: d.last_known_disease_status,
          days_to_last_known_status: d.days_to_last_known_status
        }) ELSE NULL END AS diagnoses,
        CASE WHEN spec IS NOT NULL THEN COLLECT(DISTINCT {
          specimen_id: spec.specimen_id
        }) ELSE NULL END AS specimens,
        CASE WHEN samp IS NOT NULL THEN COLLECT(DISTINCT {
          sample_id: samp.sample_id,
          sample_type: samp.sample_type,
          sample_tumor_status: samp.sample_tumor_status,
          sample_anatomic_site: samp.sample_anatomic_site,
          sample_age_at_collection: samp.sample_age_at_collection,
          derived_from_specimen: samp.derived_from_specimen,
          biosample_accession: samp.biosample_accession
        }) ELSE NULL END AS samples
    "

  - index_name: subject_ids_list
    type: neo4j
    # type mapping for each property of the index
    mapping:
      subjectIds:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:participant)-->(s:study)
      RETURN
        CASE WHEN p IS NOT NULL THEN COLLECT(DISTINCT toLower(p.participant_id)) END AS subjectIds
  "

# Subject IDs index
  - index_name: subject_ids
    type: neo4j
    # type mapping for each property of the index
    mapping:
      phs_accession:
        type: keyword
      subject_id:
        type: keyword
      # subject_ids must be converted into lower case
      subject_ids:
        type: keyword

    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:participant)-->(s:study)
      RETURN
        s.phs_accession AS phs_accession,
        p.participant_id AS subject_id,
        toLower(p.participant_id) AS subject_ids
    "
# About Page index
  - index_name: about_page
    type: about_file
    # type mapping for each property of the index
    mapping:
      page:
        type: search_as_you_type
      title:
        type: search_as_you_type
      primaryContentImage:
        type: text
      content:
        type: object
# Model nodes index
  - index_name: model_nodes
    type: model
    subtype: node
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      node_kw:
        type: keyword
# Model properties index
  - index_name: model_properties
    type: model
    subtype: property
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_kw:
        type: keyword
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
# Model values index
  - index_name: model_values
    type: model
    subtype: value
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
      value:
        type: search_as_you_type
      value_kw:
        type: keyword
